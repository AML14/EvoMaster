package org.evomaster.core.search.impact

/**
 * created by manzh on 2019-10-31
 */
class ImpactsOfIndividual(

        /**
         * key -> id of genes generated by [GeneIdUtil]
         * value -> impact info
         */
        val initializationGeneImpacts : MutableList<MutableMap<String, GeneImpact>> = mutableListOf(),
        /**
         * key -> id of genes generated by [GeneIdUtil]
         * value -> impact info
         */
        val actionGeneImpacts : MutableList<MutableMap<String, GeneImpact>> = mutableListOf(),
        /**
         * a history of structures of [this] with best fitness
         */
        val impactsOfStructure : ActionStructureImpact = ActionStructureImpact("StructureSize"),
        /**
         * key -> target id
         * value -> fitness value
         */
        val reachedTargets : MutableMap<Int, Double> = mutableMapOf()
) {

    private fun copyImpactOfGenes(geneImpacts : MutableList<MutableMap<String, GeneImpact>>) : MutableList<MutableMap<String, GeneImpact>>{
        return geneImpacts.map { e-> e.map { it.key to it.value.copy() }.toMap().toMutableMap() }.toMutableList()
    }

    private fun cloneImpactOfGenes(geneImpacts : MutableList<MutableMap<String, GeneImpact>>) : MutableList<MutableMap<String, GeneImpact>>{
        return geneImpacts.map { e-> e.map { it.key to it.value.clone() }.toMap().toMutableMap() }.toMutableList()
    }

    fun copy() : ImpactsOfIndividual{
        return ImpactsOfIndividual(
                copyImpactOfGenes(initializationGeneImpacts),
                copyImpactOfGenes(actionGeneImpacts),
                impactsOfStructure.copy(),
                reachedTargets.map { it.key to it.value }.toMap().toMutableMap()
        )
    }

    fun clone() : ImpactsOfIndividual{
        return ImpactsOfIndividual(
                cloneImpactOfGenes(initializationGeneImpacts),
                cloneImpactOfGenes(actionGeneImpacts),
                impactsOfStructure.clone(),
                reachedTargets.map { it.key to it.value }.toMap().toMutableMap()
        )
    }

    fun getGene(geneId: String, actionIndex: Int?, isIndex4Init : Boolean?) : Impact?{
        actionIndex?:return actionGeneImpacts.first()[geneId]
        isIndex4Init?:throw IllegalArgumentException("isIndex4Init is not specified")
        if (isIndex4Init)
            return initializationGeneImpacts[actionIndex][geneId]
        else
            return actionGeneImpacts[actionIndex][geneId]
    }



    fun addOrUpdateGeneImpacts(actionIndex : Int, geneId : String, impact: GeneImpact, newLine: Boolean, forInit : Boolean) {
        if (forInit)
            addOrUpdateGeneImpacts(initializationGeneImpacts, actionIndex, geneId, impact, newLine)
        else
            addOrUpdateGeneImpacts(actionGeneImpacts, actionIndex, geneId, impact, newLine)
    }

    fun addOrUpdateGeneImpacts(actionIndex : Int, mutableMap: MutableMap<String, GeneImpact>, newLine: Boolean, forInit : Boolean) {
        if (forInit){
            if (newLine){
                initializationGeneImpacts.add(actionIndex, mutableMap)
            }else{
                initializationGeneImpacts[actionIndex].putAll(mutableMap)
            }
        }
        else{
            if (newLine){
                actionGeneImpacts.add(actionIndex, mutableMap)
            }else{
                actionGeneImpacts[actionIndex].putAll(mutableMap)
            }
        }
    }


    fun deleteGeneImpacts(actionIndex : Set<Int>, forInit: Boolean) {
        if (forInit)
            deleteGeneImpacts(initializationGeneImpacts, actionIndex)
        else
            deleteGeneImpacts(actionGeneImpacts, actionIndex)
    }

    private fun deleteGeneImpacts(geneImpacts : MutableList<MutableMap<String, GeneImpact>>, actionIndex : Set<Int>) {
        if (actionIndex.any { it >= geneImpacts.size })
            throw IllegalArgumentException("invalid actionIndex ${actionIndex.filter { it >= geneImpacts.size }.joinToString(",")} which is out of boundary of geneImpacts ${geneImpacts.size}")
        geneImpacts.removeAll(geneImpacts.filterIndexed { index, _ -> actionIndex.contains(index)})
    }

    private fun addOrUpdateGeneImpacts(geneImpacts : MutableList<MutableMap<String, GeneImpact>>, actionIndex : Int, geneId : String, impact: GeneImpact, newLine : Boolean) {
        if (actionIndex == geneImpacts.size)
            geneImpacts.add(mutableMapOf())
        else if (actionIndex > geneImpacts.size)
            throw IllegalArgumentException("invalid actionIndex $actionIndex which is out of boundary of geneImpacts ${geneImpacts.size}")
        if (newLine)
            geneImpacts.add(actionIndex, mutableMapOf())
        geneImpacts[actionIndex].putIfAbsent(geneId, impact)
    }

    fun exist(geneId: String) = initializationGeneImpacts.any { it.keys.contains(geneId) } || actionGeneImpacts.any { it.keys.contains(geneId) }

    fun getAllImpactfulTargets() : Set<Int>{
        return actionGeneImpacts.plus(initializationGeneImpacts).flatMap { it.values.flatMap { v->v.getTimesOfImpacts().keys } }.toSet()
    }

    fun getAllCurrentNoimpactfulTargets() : Set<Int>{
        return actionGeneImpacts.plus(initializationGeneImpacts).flatMap { it.values.flatMap { v->v.getNoImpactsFromImpactCounter().keys } }.toSet()
    }

    fun anyImpactfulInfo() : Boolean{
        return (actionGeneImpacts.plus(initializationGeneImpacts)).any { it.values.any { v->v.getTimesOfImpacts().any { t->t.value > 0 } } }
    }

    fun getAllGeneImpact(geneId: String) : List<GeneImpact>{
        return (actionGeneImpacts.plus(initializationGeneImpacts)).filter { it.keys.contains(geneId) }.flatMap { it.values }
    }

    fun getAllGeneImpact(
    ) : List<GeneImpact>{
        return (actionGeneImpacts.plus(initializationGeneImpacts)).flatMap { it.values }
    }
}