package org.evomaster.core.search.impact

import org.evomaster.core.search.Action
import org.evomaster.core.search.FitnessValue
import org.evomaster.core.search.Individual
import org.evomaster.core.search.gene.Gene
import org.evomaster.core.search.service.mutator.MutatedGeneSpecification

/**
 * created by manzh on 2019-10-31
 */
class ImpactsOfIndividual private constructor(
        /**
         * key -> id of genes generated by [GeneIdUtil]
         * value -> impact info
         */
        private val initializationGeneImpacts : MutableList<ImpactsOfAction>,
        /**
         * key -> id of genes generated by [GeneIdUtil]
         * value -> impact info
         */
        private val actionGeneImpacts : MutableList<ImpactsOfAction>,
        /**
         * a history of structures of [this] with best fitness
         */
        val impactsOfStructure : ActionStructureImpact = ActionStructureImpact("StructureSize"),
        /**
         * key -> target id
         * value -> fitness value
         */
        val reachedTargets : MutableMap<Int, Double> = mutableMapOf()
) {

    constructor(individual: Individual, fitnessValue: FitnessValue?) : this(
            initializationGeneImpacts = individual.seeInitializingActions().map { a -> ImpactsOfAction(a) }.toMutableList(),
            actionGeneImpacts = if (individual.seeActions().isEmpty()) mutableListOf(ImpactsOfAction(individual, individual.seeGenes())) else individual.seeActions().map { a -> ImpactsOfAction(a) }.toMutableList()
    ){
        if (fitnessValue!=null){
            impactsOfStructure.updateStructure(individual, fitnessValue)
            fitnessValue.getViewOfData().forEach { (t, u) ->
                reachedTargets[t] = u.distance
            }
        }
    }

    constructor() : this(mutableListOf(), mutableListOf())

    fun copy() : ImpactsOfIndividual{
        return ImpactsOfIndividual(
                initializationGeneImpacts.map { it.copy() }.toMutableList(),
                actionGeneImpacts.map { it.copy() }.toMutableList(),
                impactsOfStructure.copy(),
                reachedTargets.map { it.key to it.value }.toMap().toMutableMap()
        )
    }

    fun clone() : ImpactsOfIndividual{
        return ImpactsOfIndividual(
                initializationGeneImpacts.map { it.clone() }.toMutableList(),
                actionGeneImpacts.map { it.clone() }.toMutableList(),
                impactsOfStructure.clone(),
                reachedTargets.map { it.key to it.value }.toMap().toMutableMap()
        )
    }

    fun updateInitializationGeneImpacts(impactsOfIndividual: ImpactsOfIndividual){
        initializationGeneImpacts.clear()
        initializationGeneImpacts.addAll(impactsOfIndividual.initializationGeneImpacts)
    }

    fun getSizeOfActionImpacts(fromInitialization: Boolean) = if (fromInitialization)initializationGeneImpacts.size else actionGeneImpacts.size


    fun getGene(actionName: String?, geneId: String, actionIndex: Int?, fromInitialization : Boolean) : GeneImpact?{
        actionIndex?:return actionGeneImpacts.first().geneImpacts[geneId]
        val current = if (fromInitialization) initializationGeneImpacts else actionGeneImpacts
        if (actionIndex >= current.size)
            throw IllegalArgumentException("exceed the boundary of impacts regarding actions, i.e., size of actions is ${current.size}, but asking index is $actionIndex")
        return current[actionIndex].get(geneId, actionName)
    }

    /**
     * @return all genes whose name is [geneId]
     */
    fun getGeneImpact(geneId: String) : List<GeneImpact>{
        val list = mutableListOf<GeneImpact>()

        initializationGeneImpacts.plus(actionGeneImpacts).forEach {
            if (it.geneImpacts.containsKey(geneId))
                list.add(it.geneImpacts[geneId]!!)
        }
        return list
    }

    fun syncBasedOnIndividual(individual: Individual, mutatedGene : MutatedGeneSpecification){
        //for initialization due to db action fixing
        val diff = individual.seeInitializingActions().size - initializationGeneImpacts.size
        if (diff != 0){ //truncation
            val list = individual.seeInitializingActions().map { db->
                val name = db.getName()
                val index = individual.seeInitializingActions().indexOf(db)
                findImpactsAction(name, index, true)?:ImpactsOfAction(db)
            }
            initializationGeneImpacts.clear()
            initializationGeneImpacts.addAll(list)
        }

        //for action
        if (individual.seeActions().size != actionGeneImpacts.size)
            throw IllegalArgumentException("inconsistent size of actions and impacts")
        individual.seeActions().forEach { action->
            val actionName = action.getName()
            val index = individual.seeActions().indexOf(action)
            action.seeGenes().filter { !mutatedGene.allManipulatedGenes().contains(it) }.forEach { g->
                val id = ImpactUtils.generateGeneId(action, g)
                if (getGene(actionName, id, index, false) == null){
                    val impact = ImpactUtils.createGeneImpact(g,id)
                    actionGeneImpacts[index].addGeneImpact(actionName, impact)
                }
            }
        }
    }

    fun deleteGeneImpacts(fromInitialization: Boolean, actionIndex : Set<Int>) : Boolean{
        if (actionIndex.isEmpty()) return false
        val current = if (fromInitialization) initializationGeneImpacts else actionGeneImpacts
        if (actionIndex.max()!! >= current.size)
            return false
        actionIndex.sortedDescending().forEach {
            current.removeAt(it)
        }
        return true
    }

    fun addOrUpdateGeneImpacts(toInitialization: Boolean, actionName: String?, actionIndex : Int, newAction : Boolean, impact: GeneImpact) : Boolean{
        val current = if (toInitialization) initializationGeneImpacts else actionGeneImpacts
        if (newAction){
            if (actionIndex > current.size) return false
            current.add(actionIndex, ImpactsOfAction(actionName, listOf(impact)))
            return true
        }
        if (actionIndex >= current.size) return false
        return current[actionIndex].addGeneImpact(actionName, impact)
    }

    fun addOrUpdateGeneImpacts(toInitialization: Boolean, actionName: String?, actionIndex : Int, newAction : Boolean, impacts: MutableMap<String, GeneImpact>) : Boolean{
        val current = if (toInitialization) initializationGeneImpacts else actionGeneImpacts
        if (newAction){
            if (actionIndex > current.size) return false
            current.add(actionIndex, ImpactsOfAction(actionName, impacts))
            return true
        }
        if (actionIndex >= current.size) return false
        return current[actionIndex].addGeneImpact(actionName, impacts)
    }

    fun anyImpactfulInfo() : Boolean{
        for (a in initializationGeneImpacts.plus(actionGeneImpacts)){
            if (a.anyImpactfulInfo()) return true
        }
        return false
    }

    fun flattenAllGeneImpact() : List<GeneImpact>{
        return initializationGeneImpacts.plus(actionGeneImpacts).flatMap { it.geneImpacts.values }
    }

    fun getInitializationGeneImpact(): List<MutableMap<String, GeneImpact>>{
        return initializationGeneImpacts.map { it.geneImpacts }
    }

    fun getActionGeneImpact(): List<MutableMap<String, GeneImpact>>{
        return actionGeneImpacts.map { it.geneImpacts }
    }

    fun anyImpactInfo() : Boolean = initializationGeneImpacts.isNotEmpty() || actionGeneImpacts.isNotEmpty()

    fun getImpactsByAction(actionName : String, actionIndex : Int, fromInitialization: Boolean) : MutableMap<String, GeneImpact>{
       return getImpactsAction(actionName, actionIndex, fromInitialization).geneImpacts
    }

    private fun getImpactsAction(actionName : String, actionIndex : Int, fromInitialization: Boolean) : ImpactsOfAction{
        val current = if (fromInitialization) initializationGeneImpacts else actionGeneImpacts
        if (actionIndex >= current.size)
            throw IllegalArgumentException("exceed the boundary of impacts regarding actions, i.e., size of actions is ${current.size}, but asking index is $actionIndex")
        val actionImpacts = current[actionIndex]
        if (actionImpacts.actionName != actionName) throw IllegalArgumentException("mismatched action name, i.e., current is ${actionImpacts.actionName}, but $actionName")
        return actionImpacts
    }

    fun findImpactsByAction(actionName : String, actionIndex : Int, fromInitialization: Boolean) : MutableMap<String, GeneImpact>?{
        val found = findImpactsAction(actionName, actionIndex, fromInitialization)?:return null
        return found.geneImpacts
    }

    private fun findImpactsAction(actionName : String, actionIndex : Int, fromInitialization: Boolean) : ImpactsOfAction?{
        return try {
            getImpactsAction(actionName, actionIndex, fromInitialization)
        }catch (e : IllegalArgumentException){
            null
        }
    }
    /**
     * @property actionName name of action if action exists, versus null
     * @property geneImpacts impact info of genes of the action or the individual (actionName == null)
     */
    private data class ImpactsOfAction(val actionName : String?, val geneImpacts: MutableMap<String, GeneImpact> = mutableMapOf()){
        fun copy() : ImpactsOfAction{
            return ImpactsOfAction(actionName, geneImpacts.map { it.key to it.value.copy() }.toMap().toMutableMap())
        }

        fun clone() : ImpactsOfAction{
            return ImpactsOfAction(actionName, geneImpacts.map { it.key to it.value.clone() }.toMap().toMutableMap())
        }

        constructor(action : Action) : this(
                actionName = action.getName(),
                geneImpacts = action.seeGenes().map {
                    val id = ImpactUtils.generateGeneId(action, it)
                    id to ImpactUtils.createGeneImpact(it, id)
                }.toMap().toMutableMap())

        constructor(individual: Individual, genes : List<Gene>) : this(
                actionName = null,
                geneImpacts = genes.map {
                    val id = ImpactUtils.generateGeneId(individual, it)
                    id to ImpactUtils.createGeneImpact(it, id)
                }.toMap().toMutableMap()
        )

        constructor(actionName: String?, geneImpacts : List<GeneImpact>) : this(
                actionName = actionName,
                geneImpacts = geneImpacts.map { it.getId() to it }.toMap().toMutableMap()
        )

        /**
         * @return false mismatched action name
         */
        fun addGeneImpact(actionName: String?, geneImpact : GeneImpact, forceUpdate : Boolean = false) : Boolean{
            val name = actionName?:ImpactUtils.extractActionName(geneImpact.getId())
            if (name != actionName) return false

            if (forceUpdate && geneImpacts.containsKey(geneImpact.getId()))
                geneImpacts.replace(geneImpact.getId(), geneImpact)
            else
                geneImpacts.putIfAbsent(geneImpact.getId(), geneImpact)

            return true
        }

        /**
         * @return false mismatched action name
         */
        fun addGeneImpact(actionName: String?, geneImpact : MutableMap<String, GeneImpact>, forceUpdate : Boolean = false) : Boolean{
            val mismatched = actionName != this.actionName || geneImpact.any { ImpactUtils.extractActionName(it.key) != this.actionName }
            if (mismatched) return false

            geneImpact.forEach { (t, u) ->
                if (forceUpdate && geneImpacts.containsKey(t))
                    geneImpacts.replace(t, u)
                else
                    geneImpacts.putIfAbsent(t, u)
            }
            return true
        }

        fun exists(geneId: String, actionName: String?) : Boolean?{
            val name = actionName?:ImpactUtils.extractActionName(geneId)
            if (name != actionName) return null
            return geneImpacts.containsKey(geneId)
        }

        fun get(geneId: String, actionName: String?) : GeneImpact?{
            val name = actionName?:ImpactUtils.extractActionName(geneId)
            if (name != actionName) throw IllegalArgumentException("mismatched action name, i.e., current is ${this.actionName}, but $actionName")
            return geneImpacts[geneId]
        }

        fun anyImpactfulInfo() : Boolean = geneImpacts.any { it.value.getTimesOfImpacts().any { i->i.value > 0 } }

        fun getImpactfulTargets() : Set<Int> = geneImpacts.values.flatMap { it.getTimesOfImpacts().filter { i -> i.value > 0 }.keys }.toSet()

        fun getNoImpactTargets() : Set<Int> = geneImpacts.values.flatMap { it.getTimesOfNoImpactWithTargets().filter { i->i.value >0 }.keys  }.toSet()

        fun isMissing(actionName: String?, geneId: String) : Boolean?{
            val name = actionName?:ImpactUtils.extractActionName(geneId)
            if (name != actionName) return null
            return !geneImpacts.containsKey(geneId)
        }
    }

}