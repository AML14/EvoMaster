package org.evomaster.core.search

import org.evomaster.core.search.gene.Gene
import org.evomaster.core.search.impact.GeneImpact
import org.evomaster.core.search.impact.ActionStructureImpact
import org.evomaster.core.search.impact.ImpactUtils
import org.evomaster.core.search.impact.MutatedGeneWithContext
import org.evomaster.core.search.service.Sampler
import org.evomaster.core.search.tracer.TraceableElement
import org.evomaster.core.search.tracer.TraceableElementCopyFilter
import org.evomaster.core.search.tracer.TrackOperator
import kotlin.math.absoluteValue

/**
 * EvaluatedIndividual allows to tracking its evolution.
 * Note that tracking EvaluatedIndividual can be enabled by set EMConfig.enableTrackEvaluatedIndividual true.
 */
class EvaluatedIndividual<T>(val fitness: FitnessValue,
                             val individual: T,
                             /**
                              * Note: as the test execution could had been
                              * prematurely stopped, there might be less
                              * results than actions
                              */
                             val results: List<out ActionResult>,
                             trackOperator: TrackOperator? = null,
                             tracking : MutableList<EvaluatedIndividual<T>>? = null,
                             undoTracking : MutableList<EvaluatedIndividual<T>>? = null,
                             withImpacts : Boolean = false,
                             impactsOfGenes : MutableMap<String, GeneImpact>? = null,
                             impactsOfStructure : ActionStructureImpact? = null,
                             reachedTargets : MutableMap<Int, Double>? = null )
    : TraceableElement(trackOperator,  tracking, undoTracking) where T : Individual {

    companion object{
        const val ONLY_INDIVIDUAL = "ONLY_INDIVIDUAL"
        const val WITH_TRACK_WITH_IMPACT = "WITH_TRACK_WITH_IMPACT"
    }

    /**
     * key -> id of genes generated by [GeneIdUtil]
     * value -> impact degree
     */
    private val impactsOfGenes : MutableMap<String, GeneImpact>? = if (withImpacts) impactsOfGenes?: mutableMapOf() else null

    /**
     * a history of structures of [this] with best fitness
     */
    private val impactsOfStructure : ActionStructureImpact? = if (withImpacts) impactsOfStructure?: ActionStructureImpact("StructureSize") else null

    /**
     * key -> target id
     * value -> fitness value
     */
    private val reachedTargets : MutableMap<Int, Double>?  = if (withImpacts) reachedTargets?: mutableMapOf() else null


    /**
     * [hasImprovement] represents if [this] helps to improve Archive, e.g., reach new target.
     */
    var hasImprovement = false

    init{
        if(individual.seeActions().size < results.size){
            throw IllegalArgumentException("Less actions than results")
        }
        if(tracking!=null && tracking.isNotEmpty() && tracking.first().trackOperator !is Sampler<*>){
            throw IllegalArgumentException("first tracking operator should be a sampler")
        }
    }

    fun copy(): EvaluatedIndividual<T> {
        return EvaluatedIndividual(
                fitness.copy(),
                individual.copy() as T,
                results.map(ActionResult::copy),
                trackOperator
        )
    }

    /**
     * Note: if a test execution was prematurely stopped,
     * the number of evaluated actions would be lower than
     * the total number of actions
     */
    fun evaluatedActions() : List<EvaluatedAction>{

        val list: MutableList<EvaluatedAction> = mutableListOf()

        val actions = individual.seeActions()

        (0 until results.size).forEach { i ->
            list.add(EvaluatedAction(actions[i], results[i]))
        }

        return list
    }

    override fun copy(copyFilter: TraceableElementCopyFilter): EvaluatedIndividual<T> {
        when(copyFilter){
            TraceableElementCopyFilter.NONE -> return copy()
            TraceableElementCopyFilter.WITH_TRACK ->{
                return EvaluatedIndividual(
                        fitness.copy(),
                        individual.copy() as T,
                        results.map(ActionResult::copy),
                        trackOperator?:individual.trackOperator,
                        getTracking()?.map { it.copy() }?.toMutableList()?: mutableListOf(),
                        getUndoTracking()?.map { it.copy()}?.toMutableList()?: mutableListOf()
                )
            }

            TraceableElementCopyFilter.DEEP_TRACK -> {
                throw IllegalArgumentException("${copyFilter.name} should be not applied for EvaluatedIndividual")
//                return EvaluatedIndividual(
//                        fitness.copy(),
//                        individual.copy(TraceableElementCopyFilter.DEEP_TRACK) as T,
//                        results.map(ActionResult::copy),
//                        trackOperator?:individual.trackOperator,
//                        getTracking()?.map { it.copy() }?.toMutableList()?: mutableListOf(),
//                        getUndoTracking()?.map { it.copy()}?.toMutableList()?: mutableListOf()
//                )
            }
            else ->{
                when {
                    copyFilter.name == ONLY_INDIVIDUAL -> return EvaluatedIndividual(
                            fitness.copy(),
                            individual.copy(TraceableElementCopyFilter.WITH_TRACK) as T,
                            results.map(ActionResult::copy),
                            trackOperator
                    )
                    copyFilter.name == WITH_TRACK_WITH_IMPACT -> {
                        val copy =  EvaluatedIndividual(
                                fitness.copy(),
                                individual.copy(TraceableElementCopyFilter.NONE) as T,
                                results.map(ActionResult::copy),
                                trackOperator?:individual.trackOperator,
                                getTracking()?.map { it.copy() }?.toMutableList()?: mutableListOf(),
                                getUndoTracking()?.map { it.copy()}?.toMutableList()?: mutableListOf(),
                                withImpacts = true,
                                impactsOfGenes = impactsOfGenes!!.map { it.key to it.value.copy() as GeneImpact }.toMap().toMutableMap(),
                                impactsOfStructure = impactsOfStructure!!.copy(),
                                reachedTargets = reachedTargets!!.map { it.key to it.value }.toMap().toMutableMap()
                        )
                        return copy
                    }
                    else -> throw IllegalStateException("${copyFilter.name} is not implemented!")
                }
            }
        }
    }

    fun getHistoryOfGene(gene: Gene) : List<Gene>{
        val geneId = ImpactUtils.generateGeneId(individual, gene)
        getTracking()?: throw IllegalArgumentException("tracking is not enabled")
        return getTracking()!!.flatMap { it.individual.seeGenes().find { g->ImpactUtils.generateGeneId(it.individual, g) == geneId}.run {
            if (this == null || this::class.java.simpleName  != gene::class.java.simpleName) listOf() else listOf(this)
        } }
    }

    /**
     * get latest modification with respect to the [gene]
     */
    fun getLatestGene(gene: Gene) : Gene?{
        getTracking()?: throw IllegalArgumentException("tracking is not enabled")
        if (getTracking()!!.isEmpty()) return null
        val latestInd = getTracking()!!.last().individual

        val geneId = ImpactUtils.generateGeneId(individual, gene)

        //the individual was mutated in terms of structure, the gene might be found in history
        val latest = latestInd.seeGenes().find { ImpactUtils.generateGeneId(latestInd, it) == geneId }?:return null
        return if (latest::class.java.simpleName == gene::class.java.simpleName) latest else null
    }

    fun getImpactOfGenes() : MutableMap<String, out GeneImpact>{
        if (impactsOfGenes == null) throw IllegalStateException("this method should be invoked")
        return impactsOfGenes
    }

    fun getImpactsOfStructure() : ActionStructureImpact{
        if (impactsOfStructure == null) throw IllegalStateException("this method should be invoked")
        return impactsOfStructure
    }

    fun getReachedTarget() : MutableMap<Int, Double>{
        if (reachedTargets == null) throw IllegalStateException("this method should be invoked")
        return reachedTargets
    }


    override fun next(trackOperator: TrackOperator, next: TraceableElement, copyFilter: TraceableElementCopyFilter): EvaluatedIndividual<T>? {
        if (next !is EvaluatedIndividual<*>) throw  IllegalArgumentException("the type of next is mismatched")

        when(copyFilter){
            TraceableElementCopyFilter.NONE, TraceableElementCopyFilter.DEEP_TRACK -> throw IllegalArgumentException("incorrect invocation")
            TraceableElementCopyFilter.WITH_TRACK -> {
                return EvaluatedIndividual(
                        next.fitness.copy(),
                        next.individual.copy() as T,
                        next.results.map(ActionResult::copy),
                        trackOperator,
                        getTracking()?.plus(this)?.map { it.copy()}?.toMutableList()?: mutableListOf(this.copy()),
                        getUndoTracking()?.map { it.copy()}?.toMutableList()?: mutableListOf()
                )
            }else ->{
                if (copyFilter.name == WITH_TRACK_WITH_IMPACT){
                    val copy = EvaluatedIndividual(
                            next.fitness.copy(),
                            next.individual.copy() as T,
                            next.results.map(ActionResult::copy),
                            trackOperator,
                            getTracking()?.plus(this)?.map { it.copy()}?.toMutableList()?: mutableListOf(this.copy()),
                            getUndoTracking()?.map { it.copy()}?.toMutableList()?: mutableListOf(),
                            withImpacts = true,
                            impactsOfGenes = impactsOfGenes!!.map { it.key to it.value.copy() as GeneImpact }.toMap().toMutableMap(),
                            impactsOfStructure = impactsOfStructure!!.copy(),
                            reachedTargets = reachedTargets!!.map { it.key to it.value }.toMap().toMutableMap()
                    )
                    return copy
                }else if (copyFilter.name == ONLY_INDIVIDUAL) IllegalArgumentException("incorrect invocation")
                throw IllegalStateException("${copyFilter.name} is not implemented!")
            }
        }
    }

    override fun getUndoTracking(): MutableList<EvaluatedIndividual<T>>? {
        if(super.getUndoTracking() == null) return null
        return super.getUndoTracking() as MutableList<EvaluatedIndividual<T>>
    }

    fun isInitialized() = getImpactOfGenes().isNotEmpty() || getImpactsOfStructure().structures.isNotEmpty() || getReachedTarget().isNotEmpty()

    fun initImpacts(genesToMutate : List<Gene>){
        getTracking()?.apply {
            assert(size == 0)
        }

        genesToMutate.forEach { g ->
            ImpactUtils.createGeneImpact(g, ImpactUtils.generateGeneId(individual, g))
        }

        impactsOfStructure!!.updateStructure(this)

        fitness.getViewOfData().forEach { (t, u) ->
            getReachedTarget()[t] = u.distance
        }
    }

    /**
     * compare current with latest
     * [inTrack] indicates how to find the latest two elements to compare.
     * For instance, if the latest modification does not improve the fitness, it will be saved in [undoTracking].
     * in this case, the latest is the last of [undoTracking], not [this]
     */
    fun updateImpactOfGenes(inTrack : Boolean, mutatedGenes : MutableList<Gene>){
        assert(getTracking() != null)
        assert(getUndoTracking() != null)

        if(inTrack) assert(getTracking()!!.isNotEmpty())
        else assert(getUndoTracking()!!.isNotEmpty())

        val previous = if(inTrack) getTracking()!!.last() else this
        val next = if(inTrack) this else getUndoTracking()!!.last()

        val isAnyOverallImprovement = updateReachedTargets(fitness)
        val comparedFitness = next.fitness.computeFitnessScore() - previous.fitness.computeFitnessScore()

        val mutatedGenesWithContext = ImpactUtils.extractMutatedGeneWithContext(mutatedGenes, next.individual)

        compareWithLatest(next, previous, (isAnyOverallImprovement || comparedFitness != 0.0), mutatedGenesWithContext)
    }

    private fun compareWithLatest(next : EvaluatedIndividual<T>, previous : EvaluatedIndividual<T>, isAnyChange : Boolean, mutatedGenes: Map<String, MutableList<MutatedGeneWithContext>>){

        if (mutatedGenes.isEmpty()){ // structure mutated
            val sizeChanged = (next.individual.seeActions().size != previous.individual.seeActions().size)
            getImpactsOfStructure().countImpact(next, isAnyChange, sizeChanged)

            /*
            TODO update impactOfGenes if any deletion or addition
             */

            return
        }

        val delta = (next.fitness.computeFitnessScore() - previous.fitness.computeFitnessScore()).absoluteValue

        /*
        TODO modify the solution for updating impacts of genes
         */
        mutatedGenes.keys.forEach {
            getImpactOfGenes().getValue(it).increaseDegree(delta)
        }

    }

    private fun updateReachedTargets(fitness: FitnessValue) : Boolean{
        var isAnyOverallImprovement = false
        fitness.getViewOfData().forEach { (t, u) ->
            var previous = getReachedTarget()[t]
            if(previous == null){
                isAnyOverallImprovement = true
                previous = 0.0
                getReachedTarget()[t] = previous
            }
            isAnyOverallImprovement = isAnyOverallImprovement || u.distance > previous
            if(u.distance > previous)
                getReachedTarget()[t] = u.distance
        }
        return isAnyOverallImprovement
    }

    override fun getTracking(): List<EvaluatedIndividual<T>>? {
        val tacking = super.getTracking()?:return null
        if(tacking.all { it is EvaluatedIndividual<*> })
            return tacking as List<EvaluatedIndividual<T>>
        else
            throw IllegalArgumentException("tracking has elements with mismatched type")
    }
}