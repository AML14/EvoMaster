package org.evomaster.core.search

import org.evomaster.core.EMConfig
import org.evomaster.core.search.gene.*
import org.evomaster.core.search.impact.GeneImpact
import org.evomaster.core.search.impact.ActionStructureImpact
import org.evomaster.core.search.impact.ArchiveStringMutationUtils
import org.evomaster.core.search.impact.ImpactUtils
import org.evomaster.core.search.impact.value.StringGeneImpact
import org.evomaster.core.search.service.Sampler
import org.evomaster.core.search.service.mutator.MutatedGeneSpecification
import org.evomaster.core.search.tracer.TraceableElement
import org.evomaster.core.search.tracer.TraceableElementCopyFilter
import org.evomaster.core.search.tracer.TrackOperator

/**
 * EvaluatedIndividual allows to tracking its evolution.
 * Note that tracking EvaluatedIndividual can be enabled by set EMConfig.enableTrackEvaluatedIndividual true.
 */
class EvaluatedIndividual<T>(val fitness: FitnessValue,
                             val individual: T,
                             /**
                              * Note: as the test execution could had been
                              * prematurely stopped, there might be less
                              * results than actions
                              */
                             val results: List<out ActionResult>,
                             trackOperator: TrackOperator? = null,
                             tracking : MutableList<EvaluatedIndividual<T>>? = null,
                             undoTracking : MutableList<EvaluatedIndividual<T>>? = null,
                             /**
                              * key -> id of genes generated by [GeneIdUtil]
                              * value -> impact degree
                              */
                             private val impactsOfGenes : MutableMap<String, GeneImpact>? = null,
                             /**
                              * a history of structures of [this] with best fitness
                              */
                             private val impactsOfStructure : ActionStructureImpact? = null,
                             /**
                              * key -> target id
                              * value -> fitness value
                              */
                             private val reachedTargets : MutableMap<Int, Double>? = null
) : TraceableElement(trackOperator,  tracking, undoTracking) where T : Individual {

    companion object{
        const val ONLY_INDIVIDUAL = "ONLY_INDIVIDUAL"
        const val WITH_TRACK_WITH_IMPACT = "WITH_TRACK_WITH_IMPACT"
    }

    /**
     * [hasImprovement] represents if [this] helps to improve Archive, e.g., reach new target.
     */
    var hasImprovement = false

    init{
        if(individual.seeActions().size < results.size){
            throw IllegalArgumentException("Less actions than results")
        }
        if(tracking!=null && tracking.isNotEmpty() && tracking.first().trackOperator !is Sampler<*>){
            throw IllegalArgumentException("first tracking operator should be a sampler")
        }
    }

    constructor(fitness: FitnessValue, individual: T, results: List<out ActionResult>, enableTracking: Boolean, trackOperator: TrackOperator?, enableImpact: Boolean):
            this(fitness, individual, results,
                    trackOperator = trackOperator, tracking = if (enableTracking) mutableListOf() else null, undoTracking = if (enableTracking) mutableListOf() else null,
                    impactsOfGenes = if (enableImpact) mutableMapOf() else null, impactsOfStructure = if (enableImpact) ActionStructureImpact("StructureSize") else null,
                    reachedTargets = if (enableImpact) mutableMapOf() else null){
        if(enableImpact) initImpacts()
    }

    fun copy(): EvaluatedIndividual<T> {
        return EvaluatedIndividual(
                fitness.copy(),
                individual.copy() as T,
                results.map(ActionResult::copy),
                trackOperator
        )
    }

    /**
     * Note: if a test execution was prematurely stopped,
     * the number of evaluated actions would be lower than
     * the total number of actions
     */
    fun evaluatedActions() : List<EvaluatedAction>{

        val list: MutableList<EvaluatedAction> = mutableListOf()

        val actions = individual.seeActions()

        (0 until results.size).forEach { i ->
            list.add(EvaluatedAction(actions[i], results[i]))
        }

        return list
    }

    override fun copy(copyFilter: TraceableElementCopyFilter): EvaluatedIndividual<T> {
        when(copyFilter){
            TraceableElementCopyFilter.NONE -> return copy()
            TraceableElementCopyFilter.WITH_TRACK ->{
                return EvaluatedIndividual(
                        fitness.copy(),
                        individual.copy() as T,
                        results.map(ActionResult::copy),
                        trackOperator?:individual.trackOperator,
                        getTracking()?.map { it.copy() }?.toMutableList()?: mutableListOf(),
                        getUndoTracking()?.map { it.copy()}?.toMutableList()?: mutableListOf()
                )
            }

            TraceableElementCopyFilter.DEEP_TRACK -> {
                throw IllegalArgumentException("${copyFilter.name} should be not applied for EvaluatedIndividual")
//                return EvaluatedIndividual(
//                        fitness.copy(),
//                        individual.copy(TraceableElementCopyFilter.DEEP_TRACK) as T,
//                        results.map(ActionResult::copy),
//                        trackOperator?:individual.trackOperator,
//                        getTracking()?.map { it.copy() }?.toMutableList()?: mutableListOf(),
//                        getUndoTracking()?.map { it.copy()}?.toMutableList()?: mutableListOf()
//                )
            }
            else ->{
                when {
                    copyFilter.name == ONLY_INDIVIDUAL -> return EvaluatedIndividual(
                            fitness.copy(),
                            individual.copy(TraceableElementCopyFilter.WITH_TRACK) as T,
                            results.map(ActionResult::copy),
                            trackOperator
                    )
                    copyFilter.name == WITH_TRACK_WITH_IMPACT -> {
                        return EvaluatedIndividual(
                                fitness.copy(),
                                individual.copy(TraceableElementCopyFilter.NONE) as T,
                                results.map(ActionResult::copy),
                                trackOperator?:individual.trackOperator,
                                getTracking()?.map { it.copy() }?.toMutableList()?: mutableListOf(),
                                getUndoTracking()?.map { it.copy()}?.toMutableList()?: mutableListOf(),
                                impactsOfGenes = impactsOfGenes!!.map { it.key to it.value.copy() as GeneImpact }.toMap().toMutableMap(),
                                impactsOfStructure = impactsOfStructure!!.copy(),
                                reachedTargets = reachedTargets!!.map { it.key to it.value }.toMap().toMutableMap()
                        )
                    }
                    else -> throw IllegalStateException("${copyFilter.name} is not implemented!")
                }
            }
        }
    }

    fun getHistoryOfGene(gene: Gene, geneId : String, length : Int = -1) : List<Gene>{
        /*
        TODO if gene is not root gene
         */
        getTracking()?: throw IllegalArgumentException("tracking is not enabled")
        return getTracking()!!.flatMap { it.individual.seeGenes().find { g->ImpactUtils.generateGeneId(it.individual, g) == geneId}.run {
            if (this == null || this::class.java.simpleName  != gene::class.java.simpleName) listOf() else listOf(this)
        } }
    }

    /**
     * get latest modification with respect to the [gene]
     */
    fun getLatestGene(gene: Gene) : Gene?{
        getTracking()?: throw IllegalArgumentException("tracking is not enabled")
        if (getTracking()!!.isEmpty()) return null
        val latestInd = getTracking()!!.last().individual

        val geneId = ImpactUtils.generateGeneId(individual, gene)

        //the individual was mutated in terms of structure, the gene might be found in history
        val latest = latestInd.seeGenes().find { ImpactUtils.generateGeneId(latestInd, it) == geneId }?:return null
        return if (latest::class.java.simpleName == gene::class.java.simpleName) latest else null
    }

    fun getImpactOfGenes() : MutableMap<String, out GeneImpact>{
        if (impactsOfGenes == null) throw IllegalStateException("this method should be invoked")
        return impactsOfGenes
    }

    fun getImpactsOfStructure() : ActionStructureImpact{
        if (impactsOfStructure == null) throw IllegalStateException("this method should be invoked")
        return impactsOfStructure
    }

    fun getReachedTarget() : MutableMap<Int, Double>{
        if (reachedTargets == null) throw IllegalStateException("this method should be invoked")
        return reachedTargets
    }


    override fun next(trackOperator: TrackOperator, next: TraceableElement, copyFilter: TraceableElementCopyFilter): EvaluatedIndividual<T>? {
        if (next !is EvaluatedIndividual<*>) throw  IllegalArgumentException("the type of next is mismatched")

        when(copyFilter){
            TraceableElementCopyFilter.NONE, TraceableElementCopyFilter.DEEP_TRACK -> throw IllegalArgumentException("incorrect invocation")
            TraceableElementCopyFilter.WITH_TRACK -> {
                return EvaluatedIndividual(
                        next.fitness.copy(),
                        next.individual.copy() as T,
                        next.results.map(ActionResult::copy),
                        trackOperator,
                        getTracking()?.plus(this)?.map { it.copy()}?.toMutableList()?: mutableListOf(this.copy()),
                        getUndoTracking()?.map { it.copy()}?.toMutableList()?: mutableListOf()
                )
            }else ->{
                if (copyFilter.name == WITH_TRACK_WITH_IMPACT){
                    val copy = EvaluatedIndividual(
                            next.fitness.copy(),
                            next.individual.copy() as T,
                            next.results.map(ActionResult::copy),
                            trackOperator,
                            getTracking()?.plus(this)?.map { it.copy()}?.toMutableList()?: mutableListOf(this.copy()),
                            getUndoTracking()?.map { it.copy()}?.toMutableList()?: mutableListOf(),
                            impactsOfGenes = impactsOfGenes!!.map { it.key to it.value.copy() as GeneImpact }.toMap().toMutableMap(),
                            impactsOfStructure = impactsOfStructure!!.copy(),
                            reachedTargets = reachedTargets!!.map { it.key to it.value }.toMap().toMutableMap()
                    )
                    return copy
                }else if (copyFilter.name == ONLY_INDIVIDUAL) IllegalArgumentException("incorrect invocation")
                throw IllegalStateException("${copyFilter.name} is not implemented!")
            }
        }
    }

    override fun getUndoTracking(): MutableList<EvaluatedIndividual<T>>? {
        if(super.getUndoTracking() == null) return null
        return super.getUndoTracking() as MutableList<EvaluatedIndividual<T>>
    }

    private fun initImpacts(){
        getTracking()?.apply {
            assert(size == 0)
        }

        /*
        TODO if required -- NOTE THAT genes in db are not supported
         */
        if (individual.seeActions().isNotEmpty()){
            individual.seeActions().forEach { a->
                a.seeGenes().forEach { g->
                    val id = ImpactUtils.generateGeneId(a, g)
                    impactsOfGenes!!.getOrPut(id){ ImpactUtils.createGeneImpact(g, id)}
                }
            }
        }else{
            individual.seeGenes().forEach { g->
                val id = ImpactUtils.generateGeneId(individual, g)
                impactsOfGenes!!.getOrPut(id){ ImpactUtils.createGeneImpact(g, id)}
            }
        }

        impactsOfStructure!!.updateStructure(this)

        fitness.getViewOfData().forEach { (t, u) ->
            getReachedTarget()[t] = u.distance
        }
    }

    /**
     * compare current with latest
     * [inTrack] indicates how to find the latest two elements to compare.
     * For instance, if the latest modification does not improve the fitness, it will be saved in [undoTracking].
     * in this case, the latest is the last of [undoTracking], not [this]
     */
    fun updateImpactOfGenes(inTrack : Boolean, mutatedGenes : MutatedGeneSpecification, notCoveredTargets : Set<Int>, strategy : EMConfig.SecondaryObjectiveStrategy){
        assert(mutatedGenes.mutatedIndividual != null)
        assert(getTracking() != null)
        assert(getUndoTracking() != null)

        if(inTrack) assert(getTracking()!!.isNotEmpty())
        else assert(getUndoTracking()!!.isNotEmpty())

        val previous = if(inTrack) getTracking()!!.last() else this
        val next = if(inTrack) this else getUndoTracking()!!.last()

        /*
         it might be a problem if covered targets become worse.
         */
        val isAnyChange = updateReachedTargets(fitness) || next.fitness.isDifferent(previous.fitness, notCoveredTargets, strategy)
//        val comparedFitness = next.fitness.computeFitnessScore() - previous.fitness.computeFitnessScore()

        compareWithLatest(next, previous, isAnyChange, mutatedGenes, inTrack)
    }

    private fun compareWithLatest(next : EvaluatedIndividual<T>, previous : EvaluatedIndividual<T>, isAnyChange : Boolean, mutatedGenes: MutatedGeneSpecification, isBetter: Boolean){

        if (mutatedGenes.mutatedGenes.isEmpty()){ // structure mutated
            val sizeChanged = (next.individual.seeActions().size != previous.individual.seeActions().size)
            /*
             TODO if required position/sequence sensitive analysis
             */
            getImpactsOfStructure().countImpact(next, isAnyChange, sizeChanged)

            /*
                update impacts of genes if any new genes are added with respect to structure mutation
             */
            mutatedGenes.addedGenes.forEach {
                val id = ImpactUtils.generateGeneId(mutatedGenes.mutatedIndividual!!, it)
                impactsOfGenes!!.putIfAbsent(id, ImpactUtils.createGeneImpact(it, id))
            }

            /*
             TODO MAN: shall we update impacts of genes regarding deletion of genes?
             */

            return
        }

        val mutatedGenesWithContext = ImpactUtils.extractMutatedGeneWithContext(mutatedGenes.mutatedGenes, mutatedGenes.mutatedIndividual!!, previousIndividual = previous.individual)

        /*
        NOTE THAT if a number of selected genes to mutate is small (i.e., 3), it is likely that a number of mutated genes is more than 1 if applying 1/n (i.e., 1/3).
        we might need to further handle this kind of side effects, but it have not be handled yet.
         */
        mutatedGenesWithContext.forEach { (t, u) ->
            val impact = getImpactOfGenes().getValue(t)

            u.forEach { gc ->
                ImpactUtils.processImpact(impact, gc, isAnyChange)
            }
            if (impact is StringGeneImpact){
                //TODO StringGene is mutated one time ideally, but need to check
                assert(u.size == 1)
                val previousValue = u.first().previous as StringGene
                val mutated =  u.first().current as StringGene
                //find saveGene in [this]
                val savedGene = findGeneById(impact.id) ?: throw IllegalStateException("cannot find the gene")
            }

        }

    }

    fun findGeneById(id : String) : Gene?{
        return individual.seeGenes().find { ImpactUtils.generateGeneId(individual, it) == id }
    }

    /**
     * update fitness archived by [this]
     * return whether [fitness] archive new targets or improve distance
     */
    private fun updateReachedTargets(fitness: FitnessValue) : Boolean{
        var isAnyOverallImprovement = false
        fitness.getViewOfData().forEach { (t, u) ->
            var previous = getReachedTarget()[t]
            if(previous == null){
                isAnyOverallImprovement = true
                previous = 0.0
                getReachedTarget()[t] = previous
            }
            isAnyOverallImprovement = isAnyOverallImprovement || u.distance > previous
            if(u.distance > previous)
                getReachedTarget()[t] = u.distance
        }
        return isAnyOverallImprovement
    }

    override fun getTracking(): List<EvaluatedIndividual<T>>? {
        val tacking = super.getTracking()?:return null
        if(tacking.all { it is EvaluatedIndividual<*> })
            return tacking as List<EvaluatedIndividual<T>>
        else
            throw IllegalArgumentException("tracking has elements with mismatched type")
    }
}