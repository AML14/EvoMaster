package org.evomaster.core.search

import org.evomaster.core.EMConfig
import org.evomaster.core.search.gene.*
import org.evomaster.core.search.impact.*
import org.evomaster.core.search.service.mutator.MutatedGeneSpecification
import org.evomaster.core.search.tracer.TraceableElement
import org.evomaster.core.search.tracer.TraceableElementCopyFilter
import org.evomaster.core.search.tracer.TrackOperator
import org.evomaster.core.Lazy
import org.evomaster.core.search.service.mutator.EvaluatedMutation

/**
 * EvaluatedIndividual allows to tracking its evolution.
 * Note that tracking EvaluatedIndividual can be enabled by set EMConfig.enableTrackEvaluatedIndividual true.
 */
class EvaluatedIndividual<T>(val fitness: FitnessValue,
                             val individual: T,
                             /**
                              * Note: as the test execution could had been
                              * prematurely stopped, there might be less
                              * results than actions
                              */
                             val results: List<out ActionResult>,

                             // for tracking its history
                             trackOperator: TrackOperator? = null,
                             index: Int = -1

) : TraceableElement(trackOperator, index) where T : Individual {

    companion object{
        /**
         * only tracking individual of evaluated individual
         */
        const val ONLY_TRACKING_INDIVIDUAL_OF_EVALUATED = "ONLY_TRACKING_INDIVIDUAL_OF_EVALUATED"
        const val WITH_TRACK_WITH_IMPACT = "WITH_TRACK_WITH_IMPACT"
    }

    // TODO impact info will be refactored with archive-mutation branch
    /**
     * key -> id of genes generated by [GeneIdUtil]
     * value -> impact info
     */
    private var impactsOfGenes : MutableMap<String, GeneImpact>? = null
    /**
     * a history of structures of [this] with best fitness
     */
    private var impactsOfStructure : ActionStructureImpact? = null
    /**
     * key -> target id
     * value -> fitness value
     *
     * */
    private var reachedTargets : MutableMap<Int, Double>? = null

    private fun wrapWithImpactInfo(impactsOfGenes : MutableMap<String, GeneImpact>?, impactsOfStructure : ActionStructureImpact?, reachedTargets : MutableMap<Int, Double>?){
        this.impactsOfGenes = impactsOfGenes
        this.impactsOfStructure = impactsOfStructure
        this.reachedTargets = reachedTargets
    }

    /**
     * [hasImprovement] represents if [this] helps to improve Archive, e.g., reach new target.
     */
    var hasImprovement = false

    val clusterAssignments : MutableSet<String> = mutableSetOf<String>()

    init{
        if(individual.seeActions().size < results.size){
            throw IllegalArgumentException("Less actions than results")
        }
    }

    constructor(fitness: FitnessValue, individual: T, results: List<out ActionResult>, trackOperator: TrackOperator? = null, index: Int = -1, isRoot : Boolean = false, config : EMConfig):
            this(fitness, individual, results,
                    trackOperator = trackOperator,
                    index = index){
        if (isRoot)
            wrapWithTracking(null, config.maxLengthOfTraces, mutableListOf())
        if(config.probOfArchiveMutation > 0.0) {
            wrapWithImpactInfo(mutableMapOf(), ActionStructureImpact("StructureSize"), mutableMapOf())
            initImpacts()
        }
    }

    fun copy(): EvaluatedIndividual<T> {
        return EvaluatedIndividual(
                fitness.copy(),
                individual.copy() as T,
                results.map(ActionResult::copy),
                trackOperator,
                index
        )
    }

    /**
     * Note: if a test execution was prematurely stopped,
     * the number of evaluated actions would be lower than
     * the total number of actions
     */
    fun evaluatedActions() : List<EvaluatedAction>{

        val list: MutableList<EvaluatedAction> = mutableListOf()

        val actions = individual.seeActions()

        (0 until results.size).forEach { i ->
            list.add(EvaluatedAction(actions[i], results[i]))
        }

        return list
    }

    override fun copy(copyFilter: TraceableElementCopyFilter): EvaluatedIndividual<T> {
        if(copyFilter.name == ONLY_TRACKING_INDIVIDUAL_OF_EVALUATED){
            return EvaluatedIndividual(
                    fitness.copy(),
                    individual.copy(TraceableElementCopyFilter.WITH_TRACK) as T,
                    results.map(ActionResult::copy),
                    trackOperator
            )
        }

        val copy = copy()

        when(copyFilter){
            TraceableElementCopyFilter.NONE -> {}
            TraceableElementCopyFilter.WITH_ONLY_EVALUATED_RESULT ->{
                copy.wrapWithEvaluatedResults(evaluatedResult)
            }
            TraceableElementCopyFilter.DEEP_TRACK -> throw IllegalArgumentException("there is no need to track individual when evaluated indivdual is tracked")
            TraceableElementCopyFilter.WITH_TRACK ->{
                // the copy includes tracking info, but it is no need to include tracking info for the element in the tracking.
                //copy.wrapWithTracking(evaluatedResult, trackingHistory = tracking?.copy(TraceableElementCopyFilter.WITH_ONLY_EVALUATED_RESULT))
                copy.wrapWithTracking(evaluatedResult, trackingHistory = tracking)
            }
            else -> {
                if (copyFilter.name == WITH_TRACK_WITH_IMPACT){
                    //copy.wrapWithTracking(evaluatedResult, trackingHistory = tracking?.copy(TraceableElementCopyFilter.WITH_ONLY_EVALUATED_RESULT))
                    copy.wrapWithTracking(evaluatedResult, trackingHistory = tracking)
                    copy.wrapWithImpactInfo(
                            impactsOfGenes = impactsOfGenes?.map { it.key to it.value.copy()}?.toMap()?.toMutableMap(),
                            impactsOfStructure = impactsOfStructure?.copy(),
                            reachedTargets = reachedTargets?.map { it.key to it.value }?.toMap()?.toMutableMap()
                    )
                }else
                    throw IllegalStateException("${copyFilter.name} is not available")
            }
        }

        return copy
    }

    /**
     * TODO the fun need to be refactored when archive-mutation is merged.
     *
     * @return a history of the [gene]
     *
     * @param gene provides an example of the gene to get
     * @param geneId is a id to identify the gene
     * @param length of history
     * @param evaluatedResultRange filter the elements in the history.
     *          Regarding the evalautedResults, 1 means 'improved', 0 means 'no change', and -1 means 'worsen'.
     *          For instance, set [evaluatedResultRange] as 1..1, only gene in the 'improved' evolution can be returned
     */
    fun getHistoryOfGene(gene: Gene, geneId : String, length : Int = 1, evaluatedResultRange: IntRange? = null) : List<Gene>{
        tracking?: throw IllegalArgumentException("the element is not tracked")
        return getLast<EvaluatedIndividual<T>>(length, evaluatedResultRange).flatMap { it.individual.seeGenes().find { g->ImpactUtils.generateGeneId(it.individual, g) == geneId}.run {
            if (this == null || this::class.java.simpleName  != gene::class.java.simpleName) listOf() else listOf(this)
        } }
    }

    fun getImpactInfo() : MutableMap<String, GeneImpact> = impactsOfGenes ?: throw IllegalStateException("impact info is not collected")

    fun getImpactOfGenes(geneId : String) : GeneImpact?{
        return (impactsOfGenes?: throw IllegalStateException("impact info is not initialized"))[geneId]
    }

    fun nextForIndividual(next: TraceableElement, evaluatedResult: EvaluatedMutation): EvaluatedIndividual<T>? {
        (next as? EvaluatedIndividual<T>) ?: throw IllegalArgumentException("mismatched tracking element")

        val nextIndividual = individual.next(next.individual, TraceableElementCopyFilter.WITH_TRACK, evaluatedResult)!!

        val new = EvaluatedIndividual(
                next.fitness.copy(),
                (nextIndividual as T).copy(TraceableElementCopyFilter.WITH_TRACK) as T,
                next.results.map(ActionResult::copy),
                next.trackOperator,
                next.index
        )
        // if there exists impact info, next should be wrapped with them
        new.wrapWithImpactInfo(
                impactsOfGenes = impactsOfGenes?.map { it.key to it.value.copy() }?.toMap()?.toMutableMap(),
                impactsOfStructure = impactsOfStructure?.copy(),
                reachedTargets = reachedTargets?.map { it.key to it.value }?.toMap()?.toMutableMap()
        )
        return new
    }

    override fun next(next: TraceableElement, copyFilter: TraceableElementCopyFilter, evaluatedResult: EvaluatedMutation): EvaluatedIndividual<T>? {

        tracking?: throw IllegalStateException("cannot create next due to unavailable tracking info")
        (next as? EvaluatedIndividual<T>) ?: throw IllegalArgumentException("mismatched tracking element")

        val nextInTracking = next.copy(copyFilter)
        pushLatest(nextInTracking)

        //if (evaluatedResult < 0) return this
        val new = next.copy()

//        new.wrapWithTracking(evaluatedResult, tracking?.copy(copyFilter))

        // tracking is shared with all mutated individual originated from same sampled ind
        new.wrapWithTracking(evaluatedResult, tracking)

        //TODO revise after archive-mutation merged into master
        // if there exists impact info, next should be wrapped with them
        new.wrapWithImpactInfo(
                impactsOfGenes = impactsOfGenes?.map { it.key to it.value.copy() }?.toMap()?.toMutableMap(),
                impactsOfStructure = impactsOfStructure?.copy(),
                reachedTargets = reachedTargets?.map { it.key to it.value }?.toMap()?.toMutableMap()
        )
        return new
    }

    private fun initImpacts(){

        updateActionGenes(individual)
        updateDbActionGenes(individual, individual.seeGenes(Individual.GeneFilter.ONLY_SQL))

        impactsOfStructure!!.updateStructure(this)

        fitness.getViewOfData().forEach { (t, u) ->
            reachedTargets!![t] = u.distance
        }
    }

    fun <T:Individual> updateDbActionGenes(ind: T, genes: List<Gene>){
        genes.filter { it.isMutable() }.forEach {
            val id = ImpactUtils.generateGeneId(ind, it)
            impactsOfGenes!!.putIfAbsent(id, ImpactUtils.createGeneImpact(it, id))
        }
    }

    private fun updateActionGenes(ind: T){
        if (ind.seeActions().isNotEmpty()){
            ind.seeActions().forEach { a->
                a.seeGenes().filter { it.isMutable() }.forEach { g->
                    val id = ImpactUtils.generateGeneId(a, g)
                    impactsOfGenes!!.putIfAbsent(id, ImpactUtils.createGeneImpact(g, id))
                }
            }
        }else{
            ind.seeGenes().filter { it.isMutable() }.forEach { g->
                val id = ImpactUtils.generateGeneId(ind, g)
                impactsOfGenes!!.putIfAbsent(id, ImpactUtils.createGeneImpact(g, id))
            }
        }
    }

    /**
     * TODO refactor with archive-mutation
     *
     * compare current with latest
     * [inTrack] indicates how to find the latest two elements to compare.
     * For instance, if the latest modification does not improve the fitness, it will be saved in [undoTracking].
     * in this case, the latest is the last of [undoTracking], not [this]
     */
    fun updateImpactOfGenes(mutatedGenes: MutatedGeneSpecification, notCoveredTargets: Set<Int>, strategy: EMConfig.SecondaryObjectiveStrategy, bloatControl: Boolean){

        Lazy.assert {
            mutatedGenes.mutatedIndividual != null
            tracking != null
        }
        val lastTwo = getLast<EvaluatedIndividual<T>>(2, null)

        Lazy.assert {
            lastTwo.size == 2
        }

        val current = lastTwo.first()
        val mutated = lastTwo.last()

        val improvedTargets = mutableSetOf<Int>()
        val impactTargets = mutableSetOf<Int>()
        mutated.fitness.isDifferent(current.fitness, notCoveredTargets, improved = improvedTargets, different = impactTargets, strategy = strategy, bloatControlForSecondaryObjective = bloatControl)

        compareWithLatest(mutated, current, improvedTargets, impactTargets, mutatedGenes)
    }

    /**
     *  TODO refactor with archive-mutation
     */
    private fun compareWithLatest(next : EvaluatedIndividual<T>, previous : EvaluatedIndividual<T>, improvedTargets : Set<Int>, impactTargets: Set<Int>, mutatedGenes: MutatedGeneSpecification){
        val better = (next.evaluatedResult == EvaluatedMutation.BETTER_THAN)
        /**
         * genes of individual might be added with additionalInfoList
         */
        updateDbActionGenes(next.individual, next.individual.seeGenes(Individual.GeneFilter.ONLY_SQL))
        updateActionGenes(next.individual)
        if (mutatedGenes.mutatedGenes.isEmpty() && mutatedGenes.mutatedDbGenes.isEmpty()){ // structure mutated
            val sizeChanged = (next.individual.seeActions().size != previous.individual.seeActions().size)
            /*
             TODO if required position/sequence sensitive analysis
             */
            impactsOfStructure!!.countImpact(next, sizeChanged, impactTargets = impactTargets, improvedTargets = improvedTargets)

            /*
             TODO MAN: shall we update impacts of genes regarding deletion of genes?
             */

            return
        }
        if (mutatedGenes.addedInitializationGenes.isNotEmpty()) return

        /*
        NOTE THAT if applying 1/n, a number of mutated genes may be more than 1 (e.g., n = 2).
        This might have side effects to impact analysis, so we only collect no impact info and ignore to collect impacts info.
        But times of manipulation should be updated.
         */
        val onlyManipulation = mutatedGenes.mutatedGenes.size + mutatedGenes.mutatedDbGenes.size > 1 && impactTargets.isNotEmpty()

        val mutatedGenesWithContext = ImpactUtils.extractMutatedGeneWithContext(mutatedGenes.mutatedGeneInfo(), mutatedGenes.mutatedIndividual!!, previousIndividual = previous.individual)

        mutatedGenesWithContext.forEach { (t, u) ->
            val impact = impactsOfGenes!!.getValue(t)

            u.forEach { gc ->
                impact.countImpactWithMutatedGeneWithContext(gc, impactTargets = impactTargets, improvedTargets = improvedTargets, onlyManipulation = onlyManipulation)
            }
        }

        val mutatedDBGenesWithContext = ImpactUtils.extractMutatedDbGeneWithContext(
                mutatedGenes.mutatedDbGeneInfo(), mutatedGenes.mutatedIndividual!!, previousIndividual = previous.individual)
        mutatedDBGenesWithContext.forEach { (t, u) ->
            val impact = impactsOfGenes!!.getValue(t)

            u.forEach { gc ->
                impact.countImpactWithMutatedGeneWithContext(gc, impactTargets = impactTargets, improvedTargets = improvedTargets, onlyManipulation = onlyManipulation)
            }
        }
    }

    fun findGeneById(id : String, index : Int = -1, isDb: Boolean=false) : Gene?{
        if (!isDb){
            if (index == -1) return individual.seeGenes().find { ImpactUtils.generateGeneId(individual, it) == id }
            if (index > individual.seeActions().size)
                throw IllegalArgumentException("index $index is out of boundary of actions ${individual.seeActions().size} of the individual")
            return individual.seeActions()[index].seeGenes().find { ImpactUtils.generateGeneId(individual, it) == id }
        }
        if (index == -1) return individual.seeInitializingActions().flatMap { it.seeGenes() }.find { ImpactUtils.generateGeneId(individual, it) == id }
        if (index >= individual.seeInitializingActions().size) return null
            //throw IllegalArgumentException("index $index is out of boundary of initializing actions ${individual.seeInitializingActions().size} of the individual")
        return individual.seeInitializingActions()[index].seeGenes().find { ImpactUtils.generateGeneId(individual, it) == id }
    }

    fun assignToCluster(cluster : String) : EvaluatedIndividual<T>{
        clusterAssignments.add(cluster)
        return this
    }

    fun getClusters(): MutableSet<String> {
        return clusterAssignments
    }

    fun belongsToCluster(cluster: String) : Boolean{
        return clusterAssignments.contains(cluster)
    }
}