<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>SelectHeuristics.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">evomaster-project-report</a> &gt; <a href="../index.html" class="el_bundle">evomaster-client-java-controller</a> &gt; <a href="index.source.html" class="el_package">org.evomaster.client.java.controller.internal.db</a> &gt; <span class="el_source">SelectHeuristics.java</span></div><h1>SelectHeuristics.java</h1><pre class="source lang-java linenums">package org.evomaster.client.java.controller.internal.db;

import net.sf.jsqlparser.expression.Expression;
import net.sf.jsqlparser.expression.ExpressionVisitorAdapter;
import net.sf.jsqlparser.expression.Function;
import net.sf.jsqlparser.schema.Column;
import net.sf.jsqlparser.statement.Statement;
import net.sf.jsqlparser.statement.select.*;
import org.evomaster.client.java.controller.db.DataRow;
import org.evomaster.client.java.controller.db.QueryResult;

import java.util.List;

import static org.evomaster.client.java.controller.internal.db.ParserUtils.getWhere;

<span class="nc" id="L16">public class SelectHeuristics {</span>



    /**
     * The constraints in the WHERE clause might reference
     * fields that are not retrieved in the SELECT.
     * Therefore, we need to add them, otherwise it
     * would not be possible to calculate any heuristics
     *
     * @param select the string containing the SQL SELECT command
     * @return  the modified SQL SELECT
     */
    public static String addFieldsToSelect(String select) {

<span class="fc" id="L31">        Select stmt = asSelectStatement(select);</span>

<span class="fc" id="L33">        SelectBody selectBody = stmt.getSelectBody();</span>
<span class="pc bpc" id="L34" title="1 of 2 branches missed.">        if (selectBody instanceof PlainSelect) {</span>
<span class="fc" id="L35">            PlainSelect plainSelect = (PlainSelect) selectBody;</span>

<span class="fc" id="L37">            Expression where = plainSelect.getWhere();</span>
<span class="pc bpc" id="L38" title="1 of 2 branches missed.">            if (where == null) {</span>
                //nothing to do
<span class="nc" id="L40">                return select;</span>
            }

<span class="fc" id="L43">            List&lt;SelectItem&gt; fields = plainSelect.getSelectItems();</span>

<span class="fc" id="L45">            where.accept(new ExpressionVisitorAdapter() {</span>
                @Override
                public void visit(Column column) {

<span class="fc" id="L49">                    String target = column.toString();</span>

<span class="fc" id="L51">                    boolean found = false;</span>
<span class="fc bfc" id="L52" title="All 2 branches covered.">                    for (SelectItem si : fields) {</span>
<span class="fc" id="L53">                        SelectExpressionItem field = (SelectExpressionItem) si;</span>
<span class="fc" id="L54">                        String exp = field.getExpression().toString();</span>
<span class="fc bfc" id="L55" title="All 2 branches covered.">                        if (target.equals(exp)) {</span>
<span class="fc" id="L56">                            found = true;</span>
<span class="fc" id="L57">                            break;</span>
                        }
<span class="fc" id="L59">                    }</span>
<span class="fc bfc" id="L60" title="All 2 branches covered.">                    if (!found) {</span>
<span class="fc" id="L61">                        SelectExpressionItem item = new SelectExpressionItem();</span>
<span class="fc" id="L62">                        item.setExpression(column);</span>
<span class="fc" id="L63">                        fields.add(item);</span>
                    }
<span class="fc" id="L65">                }</span>
            });
        }

<span class="fc" id="L69">        return stmt.toString();</span>
    }

    /**
     * For example, when we have &quot;select count(*)&quot; we are not interested
     * in the count, but the actual involved fields, so we want to
     * transform it into &quot;select *&quot; by removing the count() operation.
     *
     * @param select
     * @return
     */
    public static String removeOperations(String select){

<span class="fc" id="L82">        Select stmt = asSelectStatement(select);</span>
<span class="fc" id="L83">        SelectBody selectBody = stmt.getSelectBody();</span>

<span class="pc bpc" id="L85" title="1 of 2 branches missed.">        if (selectBody instanceof PlainSelect) {</span>
<span class="fc" id="L86">            PlainSelect plainSelect = (PlainSelect) selectBody;</span>

<span class="fc" id="L88">            plainSelect.getSelectItems()</span>
<span class="fc" id="L89">                    .removeIf(item -&gt;</span>
<span class="fc" id="L90">                            ((SelectExpressionItem)item).getExpression() instanceof Function);</span>
        }

<span class="fc" id="L93">        return stmt.toString();</span>
    }


    public static String removeConstraints(String select) {

<span class="fc" id="L99">        Select stmt = asSelectStatement(select);</span>

<span class="fc" id="L101">        SelectBody selectBody = stmt.getSelectBody();</span>
<span class="fc" id="L102">        handleSelectBody(selectBody);</span>

<span class="fc" id="L104">        return stmt.toString();</span>
    }

    private static Select asSelectStatement(String select) {
<span class="fc" id="L108">        Statement stmt = ParserUtils.asStatement(select);</span>
<span class="pc bpc" id="L109" title="1 of 2 branches missed.">        if(! (stmt instanceof Select)){</span>
<span class="nc" id="L110">            throw new IllegalArgumentException(&quot;SQL statement is not a SELECT: &quot; + select);</span>
        }
<span class="fc" id="L112">        return (Select) stmt;</span>
    }

    private static void handleSelectBody(SelectBody selectBody) {
<span class="fc bfc" id="L116" title="All 2 branches covered.">        if (selectBody instanceof PlainSelect) {</span>
<span class="fc" id="L117">            PlainSelect plainSelect = (PlainSelect) selectBody;</span>
<span class="fc" id="L118">            plainSelect.setWhere(null);</span>
<span class="fc" id="L119">            plainSelect.setLimit(null);</span>
<span class="pc bpc" id="L120" title="1 of 2 branches missed.">        } else if (selectBody instanceof SetOperationList) {</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">            for(SelectBody select : ((SetOperationList) selectBody).getSelects()){</span>
<span class="fc" id="L122">                handleSelectBody(select);</span>
<span class="fc" id="L123">            }</span>
        } else {
<span class="nc" id="L125">            throw new RuntimeException(&quot;Cannot handle &quot; + selectBody.getClass());</span>
        }

<span class="fc" id="L128">    }</span>


    public static double computeDistance(String select, QueryResult data) {

<span class="fc" id="L133">        Select stmt = asSelectStatement(select);</span>

<span class="fc bfc" id="L135" title="All 2 branches covered.">        if (data.isEmpty()) {</span>
            //if no data, we have no info whatsoever
<span class="fc" id="L137">            return Double.MAX_VALUE;</span>
        }

<span class="fc" id="L140">        Expression where = getWhere(stmt);</span>
<span class="fc bfc" id="L141" title="All 2 branches covered.">        if (where == null) {</span>
            //no constraint, and at least one data point
<span class="fc" id="L143">            return 0;</span>
        }


<span class="fc" id="L147">        SqlNameContext context = new SqlNameContext(stmt);</span>
<span class="fc" id="L148">        HeuristicsCalculator calculator = new HeuristicsCalculator(context);</span>

<span class="fc" id="L150">        double min = Double.MAX_VALUE;</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">        for (DataRow row : data.seeRows()) {</span>
<span class="fc" id="L152">            double dist = calculator.computeExpression(where, row);</span>
<span class="fc bfc" id="L153" title="All 2 branches covered.">            if (dist == 0) {</span>
<span class="fc" id="L154">                return 0;</span>
            }
<span class="fc bfc" id="L156" title="All 2 branches covered.">            if (dist &lt; min) {</span>
<span class="fc" id="L157">                min = dist;</span>
            }
<span class="fc" id="L159">        }</span>

<span class="fc" id="L161">        return min;</span>
    }




}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>