<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>SqlNameContext.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">evomaster-project-report</a> &gt; <a href="../index.html" class="el_bundle">evomaster-client-java-controller</a> &gt; <a href="index.source.html" class="el_package">org.evomaster.client.java.controller.internal.db</a> &gt; <span class="el_source">SqlNameContext.java</span></div><h1>SqlNameContext.java</h1><pre class="source lang-java linenums">package org.evomaster.client.java.controller.internal.db;


import net.sf.jsqlparser.expression.Alias;
import net.sf.jsqlparser.schema.Column;
import net.sf.jsqlparser.schema.Table;
import net.sf.jsqlparser.statement.Statement;
import net.sf.jsqlparser.statement.delete.Delete;
import net.sf.jsqlparser.statement.insert.Insert;
import net.sf.jsqlparser.statement.select.*;
import net.sf.jsqlparser.statement.update.Update;
import org.evomaster.client.java.controller.api.dto.database.schema.DbSchemaDto;

import java.util.*;

/**
 * Given a column, we need to determinate to which table it
 * belongs to. This is not always simple, as SQL queries can use &quot;aliases&quot;.
 * &lt;p&gt;
 * This problem is further exacerbated by:
 * 1) a SELECT can have many sub-SELECTs inside it, each one defining their own
 * independent aliases
 * 2) a SQL command might not have all the necessary info to infer the right table
 * for a column. In those (valid) cases of ambiguity, we must refer to the schema
 */
<span class="pc bpc" id="L26" title="1 of 2 branches missed.">public class SqlNameContext {</span>

    /**
     * WARNING: in general we shouldn't use mutable DTO as internal data structures.
     * But, here, what we need is very simple (just checking for names).
     * However, note that the &quot;final&quot; here does not give much protection, as the DTOs
     * are mutable
     */
    private final DbSchemaDto schema;


    /**
     * Key -&gt; table alias,
     * Value -&gt; table name
     */
<span class="pc" id="L41">    private final Map&lt;String, String&gt; tableAliases = new HashMap&lt;&gt;();</span>

    private final Statement statement;

    //TODO will need refactoring when supporting nested SELECTs
    public static final String UNNAMED_TABLE = &quot;___unnamed_table___&quot;;


    /**
     * WARNING: should only be used in tests, to avoid each time having
     * to provide a schema for the test data
     */
<span class="fc" id="L53">    public SqlNameContext(Statement statement) {</span>
<span class="fc" id="L54">        schema = null;</span>
<span class="fc" id="L55">        this.statement = Objects.requireNonNull(statement);</span>
<span class="fc" id="L56">        computeAliases();</span>
<span class="fc" id="L57">    }</span>

<span class="nc" id="L59">    public SqlNameContext(Statement statement, DbSchemaDto schema) {</span>
<span class="nc" id="L60">        this.schema = Objects.requireNonNull(schema);</span>
<span class="nc" id="L61">        this.statement = Objects.requireNonNull(statement);</span>
<span class="nc" id="L62">        computeAliases();</span>
<span class="nc" id="L63">    }</span>


    /*
        TODO
        code here is not supporting nested SELECTs, for the moment
     */

    /**
     * Determine the name of the table that this column belongs to
     */
    public String getTableName(Column column) {

<span class="fc" id="L76">        Table table = column.getTable();</span>

<span class="fc bfc" id="L78" title="All 2 branches covered.">        if (table != null) {</span>
<span class="fc" id="L79">            return tableAliases.getOrDefault(table.getName(), table.getName());</span>
        }

<span class="fc" id="L82">        List&lt;String&gt; candidates = getTableNamesInFrom();</span>

<span class="pc bpc" id="L84" title="2 of 4 branches missed.">        assert ! candidates.isEmpty();</span>

<span class="pc bpc" id="L86" title="1 of 2 branches missed.">        if(candidates.size() == 1){</span>
<span class="fc" id="L87">            return candidates.get(0);</span>
        } else {
            //TODO case of possible ambiguity... need to check the schema
<span class="nc" id="L90">            throw new IllegalArgumentException(&quot;TODO ambiguity&quot;);</span>
        }
    }

    private List&lt;String&gt; getTableNamesInFrom() {

<span class="fc" id="L96">        FromItem fromItem = getFromItem();</span>

<span class="fc" id="L98">        List&lt;String&gt; names = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L100">        FromItemVisitorAdapter visitor = new FromItemVisitorAdapter(){</span>
            @Override
            public void visit(Table table) {
<span class="fc" id="L103">                names.add(table.getName());</span>
<span class="fc" id="L104">            }</span>
        };

<span class="fc" id="L107">        fromItem.accept(visitor);</span>

<span class="fc" id="L109">        return names;</span>
    }

    private FromItem getFromItem() {

<span class="pc bpc" id="L114" title="1 of 2 branches missed.">        if (!(statement instanceof Select)) {</span>
<span class="nc" id="L115">            throw new IllegalArgumentException(&quot;Currently only handling SELECT&quot;);</span>
        }

<span class="fc" id="L118">        SelectBody selectBody = ((Select) statement).getSelectBody();</span>
<span class="pc bpc" id="L119" title="1 of 2 branches missed.">        if (selectBody instanceof PlainSelect) {</span>
<span class="fc" id="L120">            PlainSelect plainSelect = (PlainSelect) selectBody;</span>

<span class="fc" id="L122">            return plainSelect.getFromItem();</span>
        } else {
<span class="nc" id="L124">            throw new IllegalArgumentException(&quot;Currently only handling Plain SELECTs&quot;);</span>
        }
    }


    private void computeAliases() {

<span class="fc bfc" id="L131" title="All 2 branches covered.">        if (statement instanceof Select) {</span>
<span class="fc" id="L132">            FromItem fromItem = getFromItem();</span>
<span class="fc" id="L133">            fromItem.accept(new AliasVisitor(tableAliases));</span>

<span class="fc" id="L135">            SelectBody selectBody = ((Select) statement).getSelectBody();</span>
<span class="fc" id="L136">            PlainSelect plainSelect = (PlainSelect) selectBody;</span>

<span class="fc" id="L138">            List&lt;Join&gt; joins = plainSelect.getJoins();</span>
<span class="fc bfc" id="L139" title="All 2 branches covered.">            if (joins != null) {</span>
<span class="fc" id="L140">                joins.forEach(j -&gt; j.getRightItem().accept(new AliasVisitor(tableAliases)));</span>
            }
<span class="fc bfc" id="L142" title="All 2 branches covered.">        } else if(statement instanceof Delete){</span>
            //no alias required?
<span class="fc" id="L144">            return;</span>
<span class="pc bpc" id="L145" title="1 of 2 branches missed.">        } else if(statement instanceof Update){</span>
            /*
                TODO can update have aliases?
                https://www.h2database.com/html/commands.html#update
             */
<span class="fc" id="L150">            return;</span>
        }
<span class="fc" id="L152">    }</span>


    private static class AliasVisitor extends FromItemVisitorAdapter {

        private final Map&lt;String, String&gt; aliases;

<span class="fc" id="L159">        private AliasVisitor(Map&lt;String, String&gt; aliases) {</span>
<span class="fc" id="L160">            this.aliases = aliases;</span>
<span class="fc" id="L161">        }</span>

        @Override
        public void visit(Table table) {
<span class="fc" id="L165">            handleAlias(aliases, table);</span>
<span class="fc" id="L166">        }</span>

        @Override
        public void visit(SubSelect subSelect) {
<span class="nc" id="L170">            handleAlias(aliases, subSelect);</span>
<span class="nc" id="L171">        }</span>

    }


    private static void handleAlias(Map&lt;String, String&gt; aliases, SubSelect subSelect) {
<span class="nc" id="L177">        Alias alias = subSelect.getAlias();</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">        if (alias != null) {</span>
<span class="nc" id="L179">            String aliasName = alias.getName();</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">            if (aliasName != null) {</span>
                /*
                    FIXME: need to generalize,
                    ie for when there can be several un-named sub-selects referring
                    to columns with same names
                 */
<span class="nc" id="L186">                String tableName = UNNAMED_TABLE;</span>
<span class="nc" id="L187">                aliases.put(aliasName.trim().toLowerCase(), tableName.trim().toLowerCase());</span>
            }
        }
<span class="nc" id="L190">    }</span>


    private static void handleAlias(Map&lt;String, String&gt; aliases, Table table) {
<span class="fc" id="L194">        Alias alias = table.getAlias();</span>
<span class="fc bfc" id="L195" title="All 2 branches covered.">        if (alias != null) {</span>
<span class="fc" id="L196">            String aliasName = alias.getName();</span>
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">            if (aliasName != null) {</span>
<span class="fc" id="L198">                String tableName = table.getName();</span>
<span class="fc" id="L199">                aliases.put(aliasName.trim().toLowerCase(), tableName.trim().toLowerCase());</span>
            }
        }
<span class="fc" id="L202">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>