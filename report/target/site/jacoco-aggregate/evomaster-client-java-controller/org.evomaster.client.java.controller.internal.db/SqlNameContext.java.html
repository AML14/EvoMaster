<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>SqlNameContext.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">evomaster-project-report</a> &gt; <a href="../index.html" class="el_bundle">evomaster-client-java-controller</a> &gt; <a href="index.source.html" class="el_package">org.evomaster.client.java.controller.internal.db</a> &gt; <span class="el_source">SqlNameContext.java</span></div><h1>SqlNameContext.java</h1><pre class="source lang-java linenums">package org.evomaster.client.java.controller.internal.db;


import net.sf.jsqlparser.expression.Alias;
import net.sf.jsqlparser.schema.Column;
import net.sf.jsqlparser.schema.Table;
import net.sf.jsqlparser.statement.Statement;
import net.sf.jsqlparser.statement.select.*;
import org.evomaster.client.java.controller.api.dto.database.schema.DbSchemaDto;

import java.util.*;

/**
 * Given a column, we need to determinate to which table it
 * belongs to. This is not always simple, as SQL queries can use &quot;aliases&quot;.
 * &lt;p&gt;
 * This problem is further exacerbated by:
 * 1) a SELECT can have many sub-SELECTs inside it, each one defining their own
 * independent aliases
 * 2) a SQL command might not have all the necessary info to infer the right table
 * for a column. In those (valid) cases of ambiguity, we must refer to the schema
 */
<span class="nc bnc" id="L23" title="All 2 branches missed.">public class SqlNameContext {</span>

    /**
     * WARNING: in general we shouldn't use mutable DTO as internal data structures.
     * But, here, what we need is very simple (just checking for names).
     * However, note that the &quot;final&quot; here does not give much protection, as the DTOs
     * are mutable
     */
    private final DbSchemaDto schema;


    /**
     * Key -&gt; table alias,
     * Value -&gt; table name
     */
<span class="nc" id="L38">    private final Map&lt;String, String&gt; tableAliases = new HashMap&lt;&gt;();</span>

    private final Statement statement;

    //TODO will need refactoring when supporting nested SELECTs
    public static final String UNNAMED_TABLE = &quot;___unnamed_table___&quot;;


    /**
     * WARNING: should only be used in tests, to avoid each time having
     * to provide a schema for the test data
     */
<span class="nc" id="L50">    public SqlNameContext(Statement statement) {</span>
<span class="nc" id="L51">        schema = null;</span>
<span class="nc" id="L52">        this.statement = Objects.requireNonNull(statement);</span>
<span class="nc" id="L53">        computeAliases();</span>
<span class="nc" id="L54">    }</span>

<span class="nc" id="L56">    public SqlNameContext(Statement statement, DbSchemaDto schema) {</span>
<span class="nc" id="L57">        this.schema = Objects.requireNonNull(schema);</span>
<span class="nc" id="L58">        this.statement = Objects.requireNonNull(statement);</span>
<span class="nc" id="L59">        computeAliases();</span>
<span class="nc" id="L60">    }</span>


    /*
        TODO
        code here is not supporting nested SELECTs, for the moment
     */

    /**
     * Determine the name of the table that this column belongs to
     */
    public String getTableName(Column column) {

<span class="nc" id="L73">        Table table = column.getTable();</span>

<span class="nc bnc" id="L75" title="All 2 branches missed.">        if (table != null) {</span>
<span class="nc" id="L76">            return tableAliases.getOrDefault(table.getName(), table.getName());</span>
        }

<span class="nc" id="L79">        List&lt;String&gt; candidates = getTableNamesInFrom();</span>

<span class="nc bnc" id="L81" title="All 4 branches missed.">        assert ! candidates.isEmpty();</span>

<span class="nc bnc" id="L83" title="All 2 branches missed.">        if(candidates.size() == 1){</span>
<span class="nc" id="L84">            return candidates.get(0);</span>
        } else {
            //TODO case of possible ambiguity... need to check the schema
<span class="nc" id="L87">            throw new IllegalArgumentException(&quot;TODO ambiguity&quot;);</span>
        }
    }

    private List&lt;String&gt; getTableNamesInFrom() {

<span class="nc" id="L93">        FromItem fromItem = getFromItem();</span>

<span class="nc" id="L95">        List&lt;String&gt; names = new ArrayList&lt;&gt;();</span>

<span class="nc" id="L97">        FromItemVisitorAdapter visitor = new FromItemVisitorAdapter(){</span>
            @Override
            public void visit(Table table) {
<span class="nc" id="L100">                names.add(table.getName());</span>
<span class="nc" id="L101">            }</span>
        };

<span class="nc" id="L104">        fromItem.accept(visitor);</span>

<span class="nc" id="L106">        return names;</span>
    }

    private FromItem getFromItem() {

<span class="nc bnc" id="L111" title="All 2 branches missed.">        if (!(statement instanceof Select)) {</span>
<span class="nc" id="L112">            throw new IllegalArgumentException(&quot;Currently only handling SELECT&quot;);</span>
        }

<span class="nc" id="L115">        SelectBody selectBody = ((Select) statement).getSelectBody();</span>
<span class="nc bnc" id="L116" title="All 2 branches missed.">        if (selectBody instanceof PlainSelect) {</span>
<span class="nc" id="L117">            PlainSelect plainSelect = (PlainSelect) selectBody;</span>

<span class="nc" id="L119">            return plainSelect.getFromItem();</span>
        } else {
<span class="nc" id="L121">            throw new IllegalArgumentException(&quot;Currently only handling Plain SELECTs&quot;);</span>
        }
    }


    private void computeAliases() {

<span class="nc" id="L128">        FromItem fromItem = getFromItem();</span>
<span class="nc" id="L129">        fromItem.accept(new AliasVisitor(tableAliases));</span>

<span class="nc" id="L131">        SelectBody selectBody = ((Select) statement).getSelectBody();</span>
<span class="nc" id="L132">        PlainSelect plainSelect = (PlainSelect) selectBody;</span>

<span class="nc" id="L134">        List&lt;Join&gt; joins = plainSelect.getJoins();</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">        if (joins != null) {</span>
<span class="nc" id="L136">            joins.forEach(j -&gt; j.getRightItem().accept(new AliasVisitor(tableAliases)));</span>
        }
<span class="nc" id="L138">    }</span>


    private static class AliasVisitor extends FromItemVisitorAdapter {

        private final Map&lt;String, String&gt; aliases;

<span class="nc" id="L145">        private AliasVisitor(Map&lt;String, String&gt; aliases) {</span>
<span class="nc" id="L146">            this.aliases = aliases;</span>
<span class="nc" id="L147">        }</span>

        @Override
        public void visit(Table table) {
<span class="nc" id="L151">            handleAlias(aliases, table);</span>
<span class="nc" id="L152">        }</span>

        @Override
        public void visit(SubSelect subSelect) {
<span class="nc" id="L156">            handleAlias(aliases, subSelect);</span>
<span class="nc" id="L157">        }</span>

    }


    private static void handleAlias(Map&lt;String, String&gt; aliases, SubSelect subSelect) {
<span class="nc" id="L163">        Alias alias = subSelect.getAlias();</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">        if (alias != null) {</span>
<span class="nc" id="L165">            String aliasName = alias.getName();</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">            if (aliasName != null) {</span>
                /*
                    FIXME: need to generalize,
                    ie for when there can be several un-named sub-selects referring
                    to columns with same names
                 */
<span class="nc" id="L172">                String tableName = UNNAMED_TABLE;</span>
<span class="nc" id="L173">                aliases.put(aliasName.trim().toLowerCase(), tableName.trim().toLowerCase());</span>
            }
        }
<span class="nc" id="L176">    }</span>


    private static void handleAlias(Map&lt;String, String&gt; aliases, Table table) {
<span class="nc" id="L180">        Alias alias = table.getAlias();</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">        if (alias != null) {</span>
<span class="nc" id="L182">            String aliasName = alias.getName();</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">            if (aliasName != null) {</span>
<span class="nc" id="L184">                String tableName = table.getName();</span>
<span class="nc" id="L185">                aliases.put(aliasName.trim().toLowerCase(), tableName.trim().toLowerCase());</span>
            }
        }
<span class="nc" id="L188">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>