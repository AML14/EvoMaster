<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ExecutionTracer.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">evomaster-project-report</a> &gt; <a href="../index.html" class="el_bundle">evomaster-client-java-instrumentation</a> &gt; <a href="index.source.html" class="el_package">org.evomaster.client.java.instrumentation.staticstate</a> &gt; <span class="el_source">ExecutionTracer.java</span></div><h1>ExecutionTracer.java</h1><pre class="source lang-java linenums">package org.evomaster.client.java.instrumentation.staticstate;

import org.evomaster.client.java.instrumentation.AdditionalInfo;
import org.evomaster.client.java.instrumentation.ObjectiveNaming;
import org.evomaster.client.java.instrumentation.TargetInfo;
import org.evomaster.client.java.instrumentation.heuristic.HeuristicsForJumps;
import org.evomaster.client.java.instrumentation.heuristic.Truthness;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

/**
 * Methods of this class will be injected in the SUT to
 * keep track of what the tests do execute/cover.
 */
<span class="nc" id="L20">public class ExecutionTracer {</span>

    /*
        Careful if you change the signature of any of the
        methods in this class, as they are injected in the
        bytecode instrumentation.
        Fortunately, unit tests should quickly find such
        type of issues.
     */



    /**
     * Key -&gt; the unique descriptive id of the coverage objective
     */
<span class="fc" id="L35">    private static final Map&lt;String, TargetInfo&gt; objectiveCoverage =</span>
            new ConcurrentHashMap&lt;&gt;(65536);

    /**
     * A test case can be composed by 1 or more actions, eg HTTP calls.
     * When we get the best distance for a testing target, we might
     * also want to know which action in the test led to it.
     */
<span class="fc" id="L43">    private static int actionIndex = 0;</span>

    /**
     * Besides code coverage, there might be other events that we want to
     * keep track during test execution.
     * We keep track of it separately for each action
     */
<span class="fc" id="L50">    private static final List&lt;AdditionalInfo&gt; additionalInfoList = new ArrayList&lt;&gt;();</span>


    public static void reset() {
<span class="fc" id="L54">        objectiveCoverage.clear();</span>
<span class="fc" id="L55">        actionIndex = 0;</span>
<span class="fc" id="L56">        additionalInfoList.clear();</span>
<span class="fc" id="L57">        additionalInfoList.add(new AdditionalInfo());</span>
<span class="fc" id="L58">    }</span>

    public static void setActionIndex(int index){
<span class="nc bnc" id="L61" title="All 2 branches missed.">        if(index != actionIndex) {</span>
<span class="nc" id="L62">            actionIndex = index;</span>
<span class="nc" id="L63">            additionalInfoList.add(new AdditionalInfo());</span>
        }
<span class="nc" id="L65">    }</span>

    public static List&lt;AdditionalInfo&gt; exposeAdditionalInfoList() {
<span class="fc" id="L68">        return additionalInfoList;</span>
    }

    public static void addQueryParameter(String param){
<span class="fc" id="L72">        additionalInfoList.get(actionIndex).addQueryParameter(param);</span>
<span class="fc" id="L73">    }</span>

    public static void addHeader(String header){
<span class="fc" id="L76">        additionalInfoList.get(actionIndex).addHeader(header);</span>
<span class="fc" id="L77">    }</span>

    public static Map&lt;String, TargetInfo&gt; getInternalReferenceToObjectiveCoverage() {
<span class="nc" id="L80">        return objectiveCoverage;</span>
    }

    /**
     * @return the number of objectives that have been encountered
     * during the test execution
     */
    public static int getNumberOfObjectives() {
<span class="fc" id="L88">        return objectiveCoverage.size();</span>
    }

    public static int getNumberOfObjectives(String prefix) {
<span class="fc" id="L92">        return (int) objectiveCoverage</span>
<span class="fc" id="L93">                .entrySet().stream()</span>
<span class="pc bpc" id="L94" title="1 of 4 branches missed.">                .filter(e -&gt; prefix == null || e.getKey().startsWith(prefix))</span>
<span class="fc" id="L95">                .count();</span>
    }

    /**
     * Note: only the objectives encountered so far can have
     * been recorded. So, this is a relative value, not based
     * on the code of the whole SUT (just the parts executed so far).
     * Therefore, it is quite useless for binary values (ie 0 or 1),
     * like current implementation of basic line coverage.
     *
     * @param prefix used for string matching of which objectives types
     *               to consider, eg only lines or only branches.
     *               Use &quot;&quot; or {@code null} to pick up everything
     * @return
     */
    public static int getNumberOfNonCoveredObjectives(String prefix) {

<span class="fc" id="L112">        return getNonCoveredObjectives(prefix).size();</span>
    }

    public static Set&lt;String&gt; getNonCoveredObjectives(String prefix) {

<span class="fc" id="L117">        return objectiveCoverage</span>
<span class="fc" id="L118">                .entrySet().stream()</span>
<span class="pc bpc" id="L119" title="1 of 4 branches missed.">                .filter(e -&gt; prefix == null || e.getKey().startsWith(prefix))</span>
<span class="fc bfc" id="L120" title="All 2 branches covered.">                .filter(e -&gt; e.getValue().value &lt; 1)</span>
<span class="fc" id="L121">                .map(e -&gt; e.getKey())</span>
<span class="fc" id="L122">                .collect(Collectors.toSet());</span>
    }

    public static Double getValue(String id) {
<span class="fc" id="L126">        return objectiveCoverage.get(id).value;</span>
    }

    private static void updateObjective(String id, double value) {
<span class="pc bpc" id="L130" title="2 of 4 branches missed.">        if (value &lt; 0d || value &gt; 1d) {</span>
<span class="nc" id="L131">            throw new IllegalArgumentException(&quot;Invalid value &quot; + value + &quot; out of range [0,1]&quot;);</span>
        }

        /*
            In the same execution, a target could be reached several times,
            so we should keep track of the best value found so far
         */
<span class="fc bfc" id="L138" title="All 2 branches covered.">        if (objectiveCoverage.containsKey(id)) {</span>
<span class="fc" id="L139">            double previous = objectiveCoverage.get(id).value;</span>
<span class="fc bfc" id="L140" title="All 2 branches covered.">            if(value &gt; previous){</span>
<span class="fc" id="L141">                objectiveCoverage.put(id, new TargetInfo(null, id, value, actionIndex));</span>
            }
<span class="fc" id="L143">        } else {</span>
<span class="fc" id="L144">            objectiveCoverage.put(id, new TargetInfo(null, id, value, actionIndex));</span>
        }

<span class="fc" id="L147">        ObjectiveRecorder.update(id, value);</span>
<span class="fc" id="L148">    }</span>


    public static final String EXECUTED_LINE_METHOD_NAME = &quot;executedLine&quot;;
    public static final String EXECUTED_LINE_DESCRIPTOR = &quot;(Ljava/lang/String;I)V&quot;;

    /**
     * Report on the fact that a given line has been executed.
     */
    public static void executedLine(String className, int line) {
<span class="fc" id="L158">        String lineId = ObjectiveNaming.lineObjectiveName(className, line);</span>
<span class="fc" id="L159">        String classId = ObjectiveNaming.classObjectiveName(className);</span>
<span class="fc" id="L160">        updateObjective(lineId, 1d);</span>
<span class="fc" id="L161">        updateObjective(classId, 1d);</span>
<span class="fc" id="L162">    }</span>

    public static final String EXECUTING_METHOD_METHOD_NAME = &quot;executingMethod&quot;;
    public static final String EXECUTING_METHOD_DESCRIPTOR = &quot;(Ljava/lang/String;IIZ)V&quot;;

    /**
     *  Report on whether method calls have been successfully completed.
     *  Failures can happen due to thrown exceptions.
     *
     * @param className
     * @param line
     * @param index    as there can be many method calls on same line, need to differentiate them
     * @param completed whether the method call was successfully completed.
     */
    public static void executingMethod(String className, int line, int index, boolean completed){
<span class="fc" id="L177">        String id = ObjectiveNaming.successCallObjectiveName(className, line, index);</span>
<span class="fc bfc" id="L178" title="All 2 branches covered.">        if(completed) {</span>
<span class="fc" id="L179">            updateObjective(id, 1d);</span>
        } else {
<span class="fc" id="L181">            updateObjective(id, 0.5);</span>
        }
<span class="fc" id="L183">    }</span>


    //---- branch-jump methods --------------------------

    private static void updateBranch(String className, int line, int branchId, Truthness t) {

        /*
            Note: when we have
            if(x &gt; 0){}

            the &quot;jump&quot; to &quot;else&quot; branch is done if that is false.
            So, the actual evaluated condition is the negation, ie
            x &lt;= 0
         */

<span class="fc" id="L199">        String forThen = ObjectiveNaming.branchObjectiveName(className, line, branchId, true);</span>
<span class="fc" id="L200">        String forElse = ObjectiveNaming.branchObjectiveName(className, line, branchId, false);</span>

<span class="fc" id="L202">        updateObjective(forElse, t.getOfTrue());</span>
<span class="fc" id="L203">        updateObjective(forThen, t.getOfFalse());</span>
<span class="fc" id="L204">    }</span>

    public static final String EXECUTING_BRANCH_JUMP_METHOD_NAME = &quot;executingBranchJump&quot;;


    public static final String JUMP_DESC_1_VALUE = &quot;(IILjava/lang/String;II)V&quot;;

    public static void executingBranchJump(
            int value, int opcode, String className, int line, int branchId) {

<span class="fc" id="L214">        Truthness t = HeuristicsForJumps.getForSingleValueJump(value, opcode);</span>

<span class="fc" id="L216">        updateBranch(className, line, branchId, t);</span>
<span class="fc" id="L217">    }</span>


    public static final String JUMP_DESC_2_VALUES = &quot;(IIILjava/lang/String;II)V&quot;;

    public static void executingBranchJump(
            int firstValue, int secondValue, int opcode, String className, int line, int branchId) {

<span class="fc" id="L225">        Truthness t = HeuristicsForJumps.getForValueComparison(firstValue, secondValue, opcode);</span>

<span class="fc" id="L227">        updateBranch(className, line, branchId, t);</span>
<span class="fc" id="L228">    }</span>

    public static final String JUMP_DESC_OBJECTS =
            &quot;(Ljava/lang/Object;Ljava/lang/Object;ILjava/lang/String;II)V&quot;;

    public static void executingBranchJump(
            Object first, Object second, int opcode, String className, int line, int branchId) {

<span class="nc" id="L236">        Truthness t = HeuristicsForJumps.getForObjectComparison(first, second, opcode);</span>

<span class="nc" id="L238">        updateBranch(className, line, branchId, t);</span>
<span class="nc" id="L239">    }</span>


    public static final String JUMP_DESC_NULL =
            &quot;(Ljava/lang/Object;ILjava/lang/String;II)V&quot;;

    public static void executingBranchJump(
            Object obj, int opcode, String className, int line, int branchId) {

<span class="nc" id="L248">        Truthness t = HeuristicsForJumps.getForNullComparison(obj, opcode);</span>

<span class="nc" id="L250">        updateBranch(className, line, branchId, t);</span>
<span class="nc" id="L251">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>